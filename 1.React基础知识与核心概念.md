React 基础知识与核心概念
    JSX、组件、State、事件处理

1、JSX 简介
    JSX 是什么：JS 语法糖，最终被 Babel 编译成 React.createElement(type, props, ...children)。理解编译结果有利于理解虚拟 DOM 结构。

    // JSX
    const el = <div id="a">Hello</div>;
    // 编译后（简化）
    const el = React.createElement('div', { id: 'a' }, 'Hello');

    列表渲染：array.map(item => <li key={item.id}>{item.name}</li>) — 必须掌握 key 的含义与使用。
    // 错误示例（缺少 key）
    const items = [{ id: 1, name: 'A' }, { id: 2, name: 'B' }];
    const list = items.map(item => <li>{item.name}</li>); // 警告：列表项应该有一个唯一的 key 属性

    // 正确示例（添加 key）
    const items = [{ id: 1, name: 'A' }, { id: 2, name: 'B' }];
    const list = items.map(item => <li key={item.id}>{item.name}</li>);

常见面试题

JSX 最终会被转为什么？（回答 React.createElement）

为什么 key 不能用数组索引？举例说明复用导致的问题。
    因为数组索引不是唯一的，当数组项发生变化时，索引也会变化，这会导致 React 认为是不同的元素，从而触发重新渲染。

style 传字符串还是对象？如何写 --variable 等 CSS 变量？
    推荐使用对象形式，因为它更灵活，支持动态样式。
    // 字符串形式
    <div style="color: red;">Hello</div>
    // 对象形式
    <div style={{ color: 'red' }}>Hello</div>
    // 写 --variable 等 CSS 变量
    <div style={{ '--variable': 'value' }}>Hello</div>


2、组件
    函数组件：const MyComponent = () => <div>Hello</div>;
    类组件：class MyComponent extends React.Component { render() { return <div>Hello</div>; } }
    组件的 props：<MyComponent name="World" /> 中 name 是 props。
    组件的 state：this.state = { count: 0 } 中 count 是 state。

组件渲染与性能
    重新渲染触发点：props 改变、state 改变、父组件重新渲染。
    优化手段：React.memo、useMemo、useCallback、PureComponent、shouldComponentUpdate、拆分组件、懒加载（React.lazy + Suspense）。
    Context 的代价与优化（避免频繁变更的 Context 值，或者把频繁变化的数据单独拆分）。
    懒加载与代码分割：React.lazy、动态 import()。

常见面试题

组件复用的几种模式？优缺点？
    函数组件（无状态组件）：简单、性能好，适用于展示型组件。
    类组件（有状态组件）：功能强大，适用于需要管理状态的组件。
    组合组件：通过组合多个组件实现复用，如 <MyComponent><ChildComponent /></MyComponent>。
    继承组件：通过继承父组件实现复用，如 class MyComponent extends ParentComponent { render() { return super.render(); } }。

类组件和函数组件的区别？什么时候用类组件？
    类组件有状态（state）和生命周期方法，函数组件没有。
    类组件需要继承 React.Component，函数组件直接返回 JSX。
    类组件适用于需要管理状态或使用生命周期方法的场景，函数组件适用于展示型组件。

解释 React.memo、useMemo、useCallback 的区别与使用场景。
    React.memo：对函数组件进行浅比较，只有当 props 改变时才重新渲染。
    useMemo：缓存计算结果，只有依赖项改变时才重新计算。
    useCallback：缓存函数实例，只有依赖项改变时才重新创建。

如何实现一个简单的 HOC？如何避免 HOC 的 ref 穿透问题？
    简单 HOC 示例：
    const withLogger = (WrappedComponent) => {
        return class extends React.Component {
            componentDidMount() {
                console.log('Mounted');
            }
            render() {
                return <WrappedComponent {...this.props} />;
            }
        }
    }
    

3、State 管理、更新、原理与模式
    State 概念：组件的局部可变数据（应保持不可变更新习惯）。

    ****类组件**** this.setState：
        可能是异步批量更新（React 在事件回调中会批量合并，需了解回调或函数式更新）。

        可传对象或函数：this.setState(prev => ({ count: prev.count + 1 })) — 理解函数式更新应对并发更新。

    ****函数组件**** useState：
        const [state, setState] = useState(initial)

        setState 替换（整个值）或对对象需要手动合并：setState(prev => ({ ...prev, foo: 1 }))

        初始值为函数：useState(() => expensiveInit())

    useReducer：复杂 state 或多子值更新时的替代方案；理解 reducer、action、dispatch。

    状态提升（Lifting state up）：多组件共享时把 state 提升到共同父组件。

    不要滥用 derived state（从 props 派生的 state）— 容易导致不同步，正确做法是计算或使用 memo。

并发、批处理与最新特性（面试点）

    批处理（batching）：React 会合并多次 setState 以优化渲染（了解事件处理和原生异步回调中的差别）。

    并发模式（experimental）：setState 的优先级、调度行为会不同（知道概念即可；不要过分展开）。

    不可变性：用 spread 或 immer 来保证新引用以触发更新；避免直接修改对象/数组。

常见面试题

    setState 是异步的吗？为什么传函数比传对象更稳健？
        setState 是异步的，因为 React 会批量处理 setState 调用以优化渲染。
        传函数比传对象更稳健，因为函数式更新可以确保基于最新 state 进行更新，避免并发更新时的问题。

    useState 的 lazy initialization 是怎么工作的？
        当 useState 接收函数作为初始值时，会在组件挂载时调用该函数，而不是在每次渲染时调用。

    useReducer 与 useState 的选择场景？
        useState 适用于简单的状态管理，而 useReducer 适用于复杂的状态管理，如多子值更新或需要自定义逻辑的场景。

    如何避免在子组件中重复创建函数导致不必要渲染？
        可以使用 useCallback 来缓存函数实例，只有依赖项改变时才重新创建。



4、事件处理 （SyntheticEvent、绑定、表单）
必会点

    SyntheticEvent（合成事件）：React 在浏览器事件上做的跨平台封装（兼容性）。理解事件对象的基本用法。

    事件绑定：

        函数组件直接 onClick={() => doSomething()} 或 onClick={handleClick}

        类组件需要 this 绑定：this.handleClick = this.handleClick.bind(this) 或类属性箭头函数 handleClick = () => {}

    事件委托：React 在根节点使用事件委托，提升性能（不在每个子节点单独绑定原生事件）。

    防默认/阻止冒泡：e.preventDefault()、e.stopPropagation()（和原生一样）。

    传参方式：

        onClick={() => handle(id)}

        onClick={handle.bind(null, id)}（注意性能）

    表单事件：onChange 在 React 中用于受控组件（input 的 value 与 state 同步）。注意 checkbox 的 checked 属性。

    Keyboard/Focus 事件：onKeyDown、onKeyUp、onFocus、onBlur（区别：focus 与 blur 不冒泡，使用 onFocus/onBlur）—— React 提供冒泡版本。


5 列表、key 与 Reconciliation（拓展核心）
    必会点

        key 的用途与正确写法（使用稳定 ID）。

        列表中元素复用导致的问题示例（表单输入错位等）。

        Reconciliation 的基本规则（类型不同重建、相同类型对比 props、key 用于同层对比）。

6、Hooks 
    必会 Hooks

        useState、useEffect、useRef、useMemo、useCallback、useContext、useReducer、useLayoutEffect（区别于 useEffect：同步执行于 DOM 更新后但绘制前，常用于测量布局）

        自定义 Hook 的写法（复用逻辑）与命名规则（use 前缀）。

    深入理解（面试点）

        useEffect 的依赖数组陷阱，如何正确声明依赖（eslint-plugin-react-hooks 的规则原理）。

        闭包问题：在 Effect 或回调中引用旧 state 的经典陷阱，如何用依赖或 ref 解决。

        useMemo/useCallback 的误用：不能滥用，只有在创建值/函数昂贵或作为依赖导致子组件重复渲染时才有意义。

    常见面试题

        讲讲 useEffect 的执行时机与 cleanup 机制。
            useEffect 会在每次渲染后执行，包括初始渲染。
            可以返回一个函数作为 cleanup 机制，在组件卸载或依赖项改变时执行。

        为什么在回调中使用 state 可能得到“旧值”？如何修复？
            因为 React 会批量处理 setState 调用，回调中使用的 state 可能不是最新的。
            修复方法：使用函数式更新或依赖项数组声明 state 作为依赖。
            示例：useEffect(() => { console.log(count); }, [count]);
    
7、 常见面试题（精选可背）

    JSX 是如何被编译的？React.createElement 的返回结构是什么？
        JSX 会被 Babel 等工具编译为 React.createElement 调用。
        React.createElement 返回一个对象，包含 type（组件类型或标签名）、props（属性）、children（子节点）。

    key 的作用是什么？为什么不建议用索引作为 key？
        key 用于 React 内部标识元素，帮助 Diff 算法快速判断是否复用元素。
        不建议用索引作为 key，因为索引会改变时会导致性能问题（如添加/删除元素时）。 

    setState 为什么可能是异步的？给出并发更新下如何保证正确递增的示例。
        setState 是异步的，因为 React 会批量处理 setState 调用以优化渲染。
        并发更新时，使用函数式更新可以确保基于最新 state 进行更新，避免并发更新时的问题。
        示例：setCount(count => count + 1); 

    useEffect 的依赖数组为空、未列出某依赖、带某依赖时分别会怎样？cleanup 什么时候执行？
        依赖数组为空时，Effect 会在每次渲染后执行（类似于 componentDidMount 和 componentDidUpdate）。
        未列出某依赖时，Effect 会在每次渲染后执行（包括依赖项改变）。只在组件挂载时执行一次。
        带某依赖时，Effect 会在依赖项改变时执行（包括初始渲染）。
        cleanup 会在组件卸载或依赖项改变时执行（用于清理资源，如取消订阅）。

    useMemo 和 useCallback 有什么区别？什么时候使用？
        useMemo 用于缓存计算结果，只有依赖项改变时才重新计算。
        useCallback 用于缓存函数实例，只有依赖项改变时才重新创建。
        一般情况下，使用 useMemo 缓存计算结果，使用 useCallback 缓存函数实例。

    解释合成事件（SyntheticEvent）与事件委托。
        合成事件是 React 封装的事件对象，跨浏览器兼容（如 e.preventDefault() 与 e.stopPropagation()）。
        React 使用事件委托机制，将事件处理函数绑定在根节点（如 document），提升性能（不在每个子节点单独绑定原生事件）。

    React 怎样进行 Diff？如果两个不同 type 的节点被比较，会发生什么？
        React 使用基于树的 Diff 算法，比较新旧树的差异。
        如果两个节点的 type 不同，React 会直接销毁旧节点并创建新节点。

    受控组件与非受控组件的区别，如何实现文件上传的非受控组件？
        受控组件：组件的状态由 React 管理，通过 onChange 事件更新。
        非受控组件：组件的状态由 DOM 管理，通过 ref 访问。
        实现文件上传的非受控组件：使用 ref 引用 input 元素，在需要时调用 ref.current.click() 触发文件选择对话框。

    为什么要避免直接修改 state？说明不可变性带来的好处。
        直接修改 state 会导致不可预测的行为，因为 React 依赖于不可变性来判断是否需要重新渲染。
        不可变性带来的好处：
            1. 简化状态管理：不需要手动处理状态的更新，React 会自动处理。
            2. 避免副作用：直接修改 state 可能会导致副作用，而不可变性可以避免这种情况。
            3. 性能优化：React 可以通过不可变性来判断是否需要重新渲染，避免不必要的渲染。

    如何优化一个渲染非常慢的列表组件？（思路：虚拟化、拆分、memo、避免 inline 函数/对象）
        1. 虚拟化：只渲染可见区域的列表项，而不是全部渲染。
        2. 拆分：将列表组件拆分成多个子组件，每个子组件只渲染自己负责的部分。
        3. memo：使用 React.memo 包裹子组件，只有当 props 改变时才重新渲染。
        4. 避免 inline 函数/对象：将函数/对象作为 props 传递，而不是在 render 方法中定义。

