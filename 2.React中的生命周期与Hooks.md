React 中的生命周期与 Hooks

    React 组件的生命周期
        挂载阶段
        更新阶段
        卸载阶段
1、类组件生命周期
    1.1 挂载阶段
        constructor() 初始化state、绑定事件处理函数
        render() 渲染组件       返回JSX
        componentDidMount() 组件挂载完成后调用、适合发起网络请求、订阅、启动定时器
    1.2 更新阶段    
        触发：
            组件接收到新的 props
            组件的 state 发生变化
            父组件重新渲染导致子组件重新渲染
        shouldComponentUpdate() 组件是否需要重新渲染、返回 true 或 false
        render() 渲染组件       返回JSX
        componentDidUpdate() 组件更新完成后调用、适合处理依赖于 props 或 state 变化的操作
    1.3 卸载阶段
        componentWillUnmount() 组件卸载前调用、适合取消订阅、清除定时器、释放资源
    1.4 错误处理
        componentDidCatch() 组件发生错误时调用、适合捕获错误、显示错误信息、记录错误日志

setState 的行为与注意

    setState 是可能被**合并（merge）**的（类组件的 state 合并是浅合并）。

    异步/同步：在 React 的事件处理、生命周期中，React 会批量合并多次 setState（事件内为批处理，原生回调/Promise 中可能不同）。在 Concurrent Mode/React 18+，批处理范围扩大。

    使用函数式 setState：当下一个 state 依赖之前 state 时，使用 this.setState(prev => newState) 避免竞态。

    不要在 render 中调用 setState（会死循环）。

2、函数组件生命周期与 Hooks

    1. Hooks 基本规则（必须牢记）

        只能在 React 函数组件或自定义 Hook 中调用（不能在条件/循环中调用）
        只能在顶层调用（保证调用顺序稳定）
        eslint-plugin-react-hooks 的两个规则：rules-of-hooks、exhaustive-deps（面试常考）
        rules-of-hooks：确保按照 React 定义的 Hooks 规则调用（如 useState、useEffect 等）。
        exhaustive-deps：检查 useEffect 的依赖数组是否完整，避免遗漏依赖项导致的问题。
    
    2.常用 Hooks（要会用、懂细节）
        useState：状态管理（类组件的 setState）
            返回：[state, setState] ，setState 用于更新 state，可以是值或函数（prev => newState）。
            多次 setState 合并：React 会批量合并多次 setState，避免频繁渲染。

        useEffect：副作用管理（类组件的 componentDidMount、componentDidUpdate、componentWillUnmount）
            触发：组件挂载完成后、每次更新完成后、组件卸载前
            依赖数组：空数组（只在挂载/卸载时执行）、依赖项数组（依赖项变化时执行）      对比规则是浅比较 Object.is
            清理函数：返回一个函数，在组件卸载前调用（如取消订阅、清除定时器） cleanup

            默认是 每次更新完成后执行（包括挂载）  || 提交后异步执行的副作用

        useLayoutEffect：布局效果（类组件的 componentDidMount、componentDidUpdate）
            触发：组件挂载完成后、每次更新完成后、组件卸载前
            依赖数组：空数组（只在挂载/卸载时执行）、依赖项数组（依赖项变化时执行）      对比规则是浅比较 Object.is
            清理函数：返回一个函数，在组件卸载前调用（如取消订阅、清除定时器） cleanup
            注意：useLayoutEffect 会阻塞浏览器渲染，应避免在其中执行耗时操作。
            
            注意它和 useEffect 的区别：
            useEffect 是异步执行的，而 useLayoutEffect 是同步执行的。

            在 DOM 更新并且在浏览器绘制之前同步执行（类似于 getSnapshotBeforeUpdate + componentDidUpdate 精细时机）
            用于读取布局并同步触发重排（慎用，可能阻塞渲染）


        useContext：上下文访问（类组件的 Context.Consumer）
            返回：上下文值
            触发：组件挂载完成后、每次更新完成后、组件卸载前
            依赖数组：空数组（只在挂载/卸载时执行）、依赖项数组（依赖项变化时执行）      对比规则是浅比较 Object.is

        useReducer：状态管理（类组件的 Redux）
            返回：[state, dispatch] ，dispatch 用于触发状态更新。
            触发：组件挂载完成后、每次更新完成后、组件卸载前
            依赖数组：空数组（只在挂载/卸载时执行）、依赖项数组（依赖项变化时执行）      对比规则是浅比较 Object.is

        useCallback：记忆函数（类组件的 memoize）
            记忆函数，避免昂贵函数重复执行 ，用于缓存函数，避免重复创建
            不是用于副作用；常见误用：把它当作保证对象恒等的手段（实质是性能提示）
            用于保证函数引用不变，避免在渲染过程中重复创建函数（导致子组件重复渲染）

        useMemo：记忆值（类组件的 memoize）
            记忆值，避免昂贵计算重复执行 ，用于缓存计算结果，避免重复计算
            不是用于副作用；常见误用：把它当作保证对象恒等的手段（实质是性能提示）

        useRef：引用值（类组件的 ref）
            返回可变的 ref 对象，其 .current 属性被初始化为传入的参数（initialValue）。  改变不会重发重渲染
            该对象在组件的整个生命周期内保持不变。
            常用于保存 DOM 元素的引用、定时器 ID 
                存储跨渲染的可变变量（避免state）

        useImperativeHandle：自定义暴露方法（类组件的 forwardRef）
            暴露实例方法给父组件（类似类组件的实例方法）
        
    3. useEffect 的关键原理与常见陷阱（面试高频）
        触发时机：组件挂载完成后、每次更新完成后、组件卸载前
        依赖数组：空数组（只在挂载/卸载时执行）、依赖项数组（依赖项变化时执行）      对比规则是浅比较 Object.is
        清理函数：返回一个函数，在组件卸载前调用（如取消订阅、清除定时器） cleanup
        常见陷阱：
            忘记添加依赖项：导致 useEffect 只在挂载时执行，而不是在依赖项变化时执行。
            依赖项包含函数：导致 useEffect 每次渲染时都执行，因为函数引用变化。
            依赖项包含对象：导致 useEffect 每次渲染时都执行，因为对象引用变化。
        
        闭包问题：   ****重要****
            effect 内捕获的变量是当次渲染的快照，若依赖没有包含某个变量，effect 中会读取旧值。解决：
                把变量放到 deps 中；或
                使用 ref 存放可变值；或
                将需要的函数/值使用 useCallback/useMemo 保证引用稳定。
        
        依赖数组：必须包含 effect 中使用的外部变量（函数、state、props），否则会有 stale data 或 bug。exhaustive-deps ESLint 能帮忙。

        cleanup：适当返回清理函数防止内存泄漏与竞态（例如取消定时器、取消订阅、abort fetch）。
        
        开发模式下的双调用：React StrictMode 在开发环境会对某些副作用做 double-invoke（挂载卸载再挂载），是为了暴露副作用不纯净问题（面试可能问这个现象的原因与如何处理）。不要依赖副作用只执行一次的假设（确保 cleanup 可被安全执行多次）。

    4、useRef 的深入理解

        useRef 返回的对象在组件整个生命周期中恒定（引用稳定）

        可用于：
        保存 DOM 引用（传给 ref）
        保留跨渲染的可变值而不触发重渲染（例如保存定时器 id、保存最新的 props 以便 effect 使用）
        注意：改变 ref.current 不会触发组件重新渲染。

    5. Hooks 的内部原理（简述，面试常问） 

        React 使用 Hook 的调用顺序来在内部数组/链表中定位每个 Hook 的状态（因此“规则”的重要性）

        每次渲染都会“重新执行”函数组件，React 在内部根据调用顺序取出对应的 Hook 状态（Fiber + hooks list）

        Hooks 状态保存于 Fiber 节点上（每个组件实例），并在更新时产生新的 Fiber（调度 & 协调）

        Concurrent Rendering（并发模式）会导致 render 可以被暂停/丢弃/重试，因此 Hooks 必须是纯的（无副作用）函数式渲染，副作用要放在 useEffect/useLayoutEffect 中。

    6. 并发特性（Concurrent Mode）对 Hooks 的影响（面试进阶）
 
        渲染可能被中断和重试 => 副作用不能放在 render 中，必须放在 effect 中

        StrictMode（开发）: 会在初次挂载时双调用组件的 render 与一些初始化逻辑以发现副作用

        新 Hooks：useTransition、startTransition、useDeferredValue 用于标记/延迟非紧急更新，影响界面优先级

    ***  6和7 很难***


四、常见面试题

    useEffect 的依赖数组为什么必须列出所有外部变量？
        为了确保 effect 在依赖项变化时执行，避免 stale data 或 bug。exhaustive-deps ESLint 能帮忙。

    函数组件中如何实现 componentDidMount 只执行一次且能安全处理副作用清理？
        示例：

        useEffect(() => {
            const id = setInterval(...);
            return () => clearInterval(id);
        }, []);

    闭包陷阱：useEffect 捕获旧 state 的解决方案？
        解决：把 state 加入 deps；或使用 useRef 存最新值；或把 callback 用 useCallback 依赖最新变量。

    如何实现 shouldComponentUpdate 的行为？
        答：用 React.memo(Component, areEqual) 或在父组件中用 useMemo 控制 props 的引用稳定性。

    为什么在事件处理器中调用 setState 多次最终只触发一次重渲染？
        答：React 会在合成事件/生命周期中批处理 setState；React 18 扩大了批处理范围。

    实现一个自定义 Hook：usePrevious(value)

        function usePrevious(value) {
            const ref = useRef();
            useEffect(() => { ref.current = value; }, [value]);
            return ref.current;
        }

        解释：useEffect 依赖项为空数组时，effect 只在挂载时执行一次，返回的清理函数在卸载时调用。

    useMemo 是缓存值还是缓存计算？什么时候不用它？
        答：缓存计算结果；当计算成本低或组件不频繁渲染时不要使用（会带来额外开销）。

    useCallback 能否解决子组件不必要渲染？有什么限制？
        答：可以减少函数引用变化从而避免子组件 shallow compare 触发；但不能解决函数内部闭包造成的数据差异；滥用会增加复杂度。

    为什么在 StrictMode 下 useEffect 可能会执行两次？如何处理？
        答：React 在开发中双调用挂载以检测不纯副作用；要确保 effect 的 cleanup 可重复安全执行，不要用双调用作为生产行为依据。

    如何安全取消 fetch 请求以避免在卸载后 setState？
        答：使用 AbortController 并在 cleanup 中调用 abort()，或在 cleanup 中设置 isMounted flag 并判断。

    useReducer 与 useState 的选择规则？
        答：当 state 较复杂（包含多个子值）或有多种更新方式 & 需要按 action 解耦逻辑时，用 useReducer 更清晰、更易测试。

五、面试必背的「答题模板」与要点（可直接在面试中说）

    描述生命周期执行顺序（类组件）并举例在哪做副作用（componentDidMount）与清理（componentWillUnmount）。

    解释 Hooks 的两条规则并说明原因（调用顺序用于内部索引）。

    说明 useEffect 的执行时机（提交后）、cleanup 机制与依赖数组作用。

    说出闭包问题如何导致 stale state，并给出 2 种解决方法（deps / ref / 函数式 setState）。

    说明 Concurrent Rendering 对副作用的影响（render 可能被重试，副作用要放 effect；StrictMode dev 下 double invoke）。

    举例说明何时用 useLayoutEffect（测量 DOM 并同步更新，以避免闪烁）。

六、面试进阶话题（大厂可能追问）

    Fiber 架构对生命周期的影响：render/commit phase 分离；render 是纯计算（无副作用），commit 才应用更改与执行 effect。

    为什么 class 的 setState 是合并浅拷贝，而 Hooks 的 state 更新是替换？：class 有对象形式 state 合并特性；useState 管理的是单个 state 值，更新替换。

    实现 Hooks 的思路（简述）：使用链表或数组在组件实例上按调用顺序存储 Hook 状态，渲染时按序读取/更新。

    SSR + Hooks（useEffect 不会在服务端运行）：副作用只在客户端执行，服务端渲染注意数据获取（可能用一些 SSR 特定方法）。

    useSyncExternalStore 的作用：在并发模式下安全订阅外部 store，保证一致性。

