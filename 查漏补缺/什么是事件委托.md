事件委托（Event Delegation）
    将子元素需要监听的事件，统一委托到父元素上处理，而不是在每个子元素上分别绑定事件。

    React内部就是通过事件委托机制来管理事件的

✅ 举个例子：

原生写法（未委托）👇

<ul id="list">
  <li>苹果</li>
  <li>香蕉</li>W
  <li>橙子</li>
</ul>

<script>
  const lis = document.querySelectorAll('li');
  lis.forEach(li => {
    li.addEventListener('click', () => {
      console.log(li.textContent);
    });
  });
</script>


上面这种方式：
👉 每个 <li> 都绑定了一个独立事件监听器。
当列表很多时，会浪费大量内存与性能。


而使用 事件委托👇

const ul = document.querySelector('#list');
ul.addEventListener('click', (e) => {
  if (e.target.tagName === 'LI') {
    console.log(e.target.textContent);
  }
});


此时：

我们只在父元素 <ul> 上绑定一次事件；

当点击 <li> 时，通过 e.target 拿到真实触发的元素；

React 内部就是用这种思路处理所有事件的。



React 事件委托的底层原理

    React的事件系统不是直接绑定在DOM上的 
    而是绑定在根元素（如document）上，通过事件冒泡机制实现事件委托。
    React是通过一种叫做合成事件 （Synthetic Event）的机制来实现跨浏览器一致性和高性能

🌳 1️⃣ React 中事件绑定的真实位置

在 React 17 以前：

    所有事件都委托在 document 上；

    例如：<div onClick={handleClick}> 并不会真的在 div 上绑定事件，而是 React 统一在 document 上监听所有类型事件；

    当真实 DOM 触发时，React 从事件对象中找到对应组件，执行回调。

    ✅ 优点：节省内存 + 提高性能。

在 React 17 之后：

    React 改为事件委托到组件挂载的根容器（root container）上，比如：

    ReactDOM.createRoot(document.getElementById('root'))

    则所有事件都会绑定在 #root 上，而不是 document。

    这样可以：

    支持多个 React 应用共存；

    避免 document 捕获影响到非 React 管理的区域。

🌐 2️⃣ React 的合成事件（SyntheticEvent）
    React 不直接使用原生事件，而是创建一个“合成事件对象”：

    function handleClick(e) {
        console.log(e.nativeEvent); // 原生事件
        console.log(e);             // React 合成事件
    }


    React 的合成事件：

        是对浏览器原生事件的封装；

        提供统一的 API（屏蔽兼容性问题）；

        实现自动清理与性能优化（事件池机制）。

🧠 三、为什么要用事件委托
优点	说明
✅ 性能好	减少大量事件监听器绑定
✅ 内存占用低	所有事件集中在容器上
✅ 动态元素也能响应	即使子元素是后生成的，也能触发事件
✅ 便于管理	React 可以集中控制所有事件流


💥 四、React 中事件委托的执行流程（底层机制）                   ******重点****

当你写：
<div onClick={handleClick}>按钮</div>

React 做了这些事👇：

1️⃣ 在根节点上绑定一个统一的 click 监听器；
2️⃣ 当你点击这个 div 时，浏览器触发原生事件；
3️⃣ React 捕获到该事件，封装为 SyntheticEvent；
4️⃣ React 模拟事件冒泡机制，从目标节点向上执行对应回调；
5️⃣ 回调执行完后，React 清理事件对象（事件池）。


⚔️ 常见面试题

💡 Q1：React 为什么不直接在元素上绑定事件？

    因为会造成性能浪费，且无法高效管理事件。

    React 用事件委托集中管理所有事件，统一在顶层监听，再通过事件冒泡机制分发事件。

💡 Q2：React 17 之后为什么不委托在 document 上了？

    因为一个页面可能有多个 React 应用实例。

    React 17 改为委托在对应的 root container 上，保证事件不跨 React 实例干扰。

💡 Q3：React 的事件和原生事件有什么区别？
    对比项	React 合成事件	原生事件
    事件类型	SyntheticEvent	Event
    注册位置	根容器（以前是 document）	当前 DOM 节点
    性能	委托统一管理	每个节点独立监听
    兼容性	已封装兼容	不同浏览器差异较大
    清理	自动清理、回收	需手动移除监听器

💡 Q4：如何在 React 中阻止事件冒泡？
function handleClick(e) {
  e.stopPropagation(); // 阻止冒泡
}
⚠️ 注意：这是 React 的 合成事件 stopPropagation()，
如果你用 e.nativeEvent.stopPropagation()，那是直接阻止原生事件传播。

🎯 面试总结速背版
知识点	要点
React 如何实现事件系统	通过事件委托 + 合成事件（SyntheticEvent）
React 事件绑定位置	React 16 及之前在 document 上，React 17+ 在 root container 上
为什么用事件委托	提高性能、减少内存消耗、统一管理
如何阻止冒泡	e.stopPropagation()（合成事件）
合成事件作用	统一兼容层，提供一致事件模型